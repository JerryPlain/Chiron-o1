# 面试伪代码清单（MICS 项目定制 + 通用高频）

这份清单目标：
- 让你在面试中被要求“现场写伪代码”时，能直接按模板输出。
- 覆盖 MICS 项目最相关题 + 算法/工程高频题。

说明：
- 严格意义上的“所有可能性”无法穷尽；这里给的是面试高频覆盖最全版本。
- 你可以把下面每段伪代码当成“口述 + 白板”模板。

## 0. 面试先手万能框架（先说再写）

```text
Input/Output 定义 -> 边界条件 -> 核心状态 -> 主循环/递归 -> 返回值 -> 复杂度
```

```pseudo
function solve(input):
    if input is invalid:
        return error_or_default

    init data_structures
    init answer

    for each unit in input:
        update state
        if early_stop_condition:
            break

    return answer
```

## 1. MICS 项目最可能被问的伪代码

### 1.1 单样本搜索主流程（`MentorInternSearch.search`）

```pseudo
function search(sample, model_set, success_log, fail_log):
    parse question, gt_answer, case_info from sample
    try:
        img_paths = locate_img(sample)
        base64_images = encode_all(img_paths)
    except error:
        write fail_log and return

    current_step = ROOT("Let's think step by step")
    mentors_scores = dict(mentor -> empty_list)
    reasoning_chains = dict()
    previous_mentors = []

    for depth in [0 .. max_depth-1]:
        candidates = []
        full_score_mentors = []
        all_zero = true

        for mentor in mentor_models:
            (new_step, full_chain) = mentor_generate_or_reuse(...)
            score = evaluate_with_interns(new_step, question, gt_answer, img_paths)

            mentors_scores[mentor].append(score)
            reasoning_chains[mentor] = full_chain

            if score > 0: all_zero = false
            add candidate(step=new_step, score=score, mentor=mentor)
            if score == 1.0: full_score_mentors.append(mentor)

        if full_score_mentors not empty:
            best = tie_break(full_score_mentors, mentors_scores, depth)
            write success_log(reasoning_chains[best], search_id=1)
            return

        if all_zero:
            write fail_log("All mentor scores are zero")
            return

        if candidates empty:
            break

        current_step = select_next_step(candidates, previous_mentors)
        previous_mentors.append(current_step.generated_by)

    # reached max_depth
    if final mentor chain exists:
        write success_log(chain, search_id=0)
    else:
        write fail_log("No valid reasoning path")
```

### 1.2 模型路由器（远程 API / 本地模型）

```pseudo
function call_model_forward(model_name, prompt, temperature, base64_images, img_paths):
    try:
        if contains(model_name, "gpt"):
            return gpt_forward(..., base64_images)
        else if contains(model_name, "gemini"):
            return gpt_forward(..., base64_images)
        else if contains(model_name, "72"):
            return qwenplus_forward(..., base64_images)
        else if contains(model_name, "qwen"):
            return qwenvl_forward(..., img_paths)
        else if contains(model_name, "internvl"):
            return internvl_forward(..., img_paths)
        else:
            return None
    except:
        return None
```

### 1.3 Intern 多次采样打分（核心评分函数）

```pseudo
function evaluate_step_with_interns(step, question, gt_answer, img_paths):
    correct = 0
    total = len(intern_models) * 2

    for intern in intern_models:
        prompt = build_evaluate_prompt(intern, question, step, img_paths)

        for temp in [temperature1, temperature2]:
            resp = call_model_forward(intern, prompt, temp, img_paths=img_paths)
            if resp invalid: continue

            answer = parse_final_answer(resp)
            if answer empty: continue

            judge_prompt = build_judge_prompt(question, answer, gt_answer)
            judge_resp = evaluator_forward(judge_prompt)
            if parse_correctness(judge_resp) == 1:
                correct += 1

    if total == 0: return 0.0
    return correct / total
```

### 1.4 候选步骤选择（带多样性 tie-break）

```pseudo
function select_next_step(candidates, previous_mentors):
    best_score = max(c.score for c in candidates)
    pool = [c for c in candidates if c.score == best_score]

    unseen = [c for c in pool if c.mentor not in previous_mentors]
    if unseen not empty:
        return random_or_rule_pick(unseen)
    return random_or_rule_pick(pool)
```

### 1.5 日志容错写入（长任务必问）

```pseudo
function safe_write_jsonl(file_handle, obj):
    line = json_encode(obj)
    file_handle.write(line + "\n")
    file_handle.flush()  # 防止长任务中断造成丢失
```

## 2. 机器学习/多模型系统面试高频伪代码

### 2.1 Beam Search（通用）

```pseudo
function beam_search(initial_state, beam_size, max_depth):
    beam = [initial_state]

    for d in [1..max_depth]:
        all_next = []
        for state in beam:
            children = expand(state)
            all_next.extend(children)

        beam = top_k(all_next, beam_size, key=score)
        if any is_terminal(state) in beam:
            return best_terminal(beam)

    return best_state(beam)
```

### 2.2 Self-Consistency（多次采样投票）

```pseudo
function self_consistency(prompt, n):
    answers = []
    for i in [1..n]:
        reasoning = sample_model(prompt, temperature>0)
        ans = extract_final_answer(reasoning)
        if ans valid: answers.append(ans)
    return majority_vote(answers)
```

### 2.3 RAG 主链路

```pseudo
function rag_answer(query):
    q_vec = embed(query)
    docs = vector_db.topk(q_vec, k)
    context = build_context(docs)
    prompt = compose(query, context)
    answer = llm_generate(prompt)
    return answer
```

### 2.4 在线评估 + 回滚

```pseudo
function deploy_with_guard(new_model, traffic_ratio):
    route traffic_ratio to new_model
    metrics = monitor(latency, error_rate, business_kpi)
    if metrics beyond_threshold:
        rollback_to_old_model()
    else:
        increase_traffic_gradually()
```

## 3. 算法题高频伪代码（最容易被临场要求手写）

### 3.1 二分查找

```pseudo
function binary_search(nums, target):
    l = 0, r = len(nums)-1
    while l <= r:
        m = l + (r-l)//2
        if nums[m] == target: return m
        if nums[m] < target: l = m+1
        else: r = m-1
    return -1
```

### 3.2 双指针（有序数组两数和）

```pseudo
function two_sum_sorted(nums, target):
    i = 0, j = len(nums)-1
    while i < j:
        s = nums[i] + nums[j]
        if s == target: return (i, j)
        if s < target: i += 1
        else: j -= 1
    return not_found
```

### 3.3 滑动窗口（最长无重复子串）

```pseudo
function longest_unique_substring(s):
    count = map()
    left = 0
    ans = 0

    for right in [0..len(s)-1]:
        count[s[right]] += 1
        while count[s[right]] > 1:
            count[s[left]] -= 1
            left += 1
        ans = max(ans, right-left+1)

    return ans
```

### 3.4 前缀和（子数组和为 K）

```pseudo
function subarray_sum_k(nums, k):
    freq = {0:1}
    prefix = 0
    ans = 0

    for x in nums:
        prefix += x
        ans += freq.get(prefix-k, 0)
        freq[prefix] = freq.get(prefix, 0) + 1

    return ans
```

### 3.5 单调栈（下一个更大元素）

```pseudo
function next_greater(nums):
    ans = array(len(nums), -1)
    stack = []  # store index, values decreasing

    for i in [0..len(nums)-1]:
        while stack not empty and nums[i] > nums[stack.top()]:
            idx = stack.pop()
            ans[idx] = nums[i]
        stack.push(i)

    return ans
```

### 3.6 BFS（最短步数）

```pseudo
function bfs_shortest(start, target):
    q = queue([start])
    visited = set([start])
    step = 0

    while q not empty:
        size = q.size()
        repeat size times:
            cur = q.pop_front()
            if cur == target: return step
            for nxt in neighbors(cur):
                if nxt not in visited:
                    visited.add(nxt)
                    q.push_back(nxt)
        step += 1

    return -1
```

### 3.7 DFS 回溯（全排列）

```pseudo
function permute(nums):
    ans = []
    used = [false] * len(nums)

    function backtrack(path):
        if len(path) == len(nums):
            ans.append(copy(path))
            return
        for i in [0..len(nums)-1]:
            if used[i]: continue
            used[i] = true
            path.append(nums[i])
            backtrack(path)
            path.pop()
            used[i] = false

    backtrack([])
    return ans
```

### 3.8 并查集（连通分量）

```pseudo
class DSU:
    parent, rank

    function find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]

    function union(a, b):
        ra = find(a), rb = find(b)
        if ra == rb: return
        if rank[ra] < rank[rb]: swap(ra, rb)
        parent[rb] = ra
        if rank[ra] == rank[rb]: rank[ra] += 1
```

### 3.9 动态规划（0/1 背包）

```pseudo
function knapsack01(weights, values, cap):
    dp = [0] * (cap + 1)
    for i in [0..n-1]:
        for c in [cap..weights[i]] descending:
            dp[c] = max(dp[c], dp[c - weights[i]] + values[i])
    return dp[cap]
```

### 3.10 链表反转

```pseudo
function reverse_list(head):
    prev = null
    cur = head
    while cur != null:
        nxt = cur.next
        cur.next = prev
        prev = cur
        cur = nxt
    return prev
```

### 3.11 LRU（哈希表 + 双向链表）

```pseudo
class LRUCache(capacity):
    map = key -> node
    list = doubly_linked_list  # MRU at head

    function get(key):
        if key not in map: return -1
        node = map[key]
        list.move_to_head(node)
        return node.value

    function put(key, value):
        if key in map:
            node = map[key]
            node.value = value
            list.move_to_head(node)
            return
        node = new Node(key, value)
        map[key] = node
        list.add_head(node)
        if size(map) > capacity:
            tail = list.remove_tail()
            delete map[tail.key]
```

## 4. 工程设计高频伪代码

### 4.1 生产者-消费者

```pseudo
queue = bounded_queue()
mutex = lock()
not_empty = condition()
not_full = condition()

function producer(item):
    lock(mutex)
    while queue.is_full(): wait(not_full, mutex)
    queue.push(item)
    signal(not_empty)
    unlock(mutex)

function consumer():
    lock(mutex)
    while queue.is_empty(): wait(not_empty, mutex)
    item = queue.pop()
    signal(not_full)
    unlock(mutex)
    return item
```

### 4.2 限流（令牌桶）

```pseudo
class TokenBucket(rate, capacity):
    tokens = capacity
    last_ts = now()

    function allow(request_n=1):
        refill()
        if tokens >= request_n:
            tokens -= request_n
            return true
        return false

    function refill():
        delta = now() - last_ts
        tokens = min(capacity, tokens + delta * rate)
        last_ts = now()
```

### 4.3 重试 + 指数退避

```pseudo
function call_with_retry(fn, max_retry):
    delay = base_delay
    for attempt in [0..max_retry]:
        try:
            return fn()
        except transient_error:
            if attempt == max_retry: raise
            sleep(delay + random_jitter())
            delay = min(delay * 2, max_delay)
```

### 4.4 幂等写入（防重复请求）

```pseudo
function handle_request(req):
    key = req.idempotency_key
    if key exists in idempotency_store:
        return idempotency_store[key]

    result = process_business(req)
    idempotency_store[key] = result
    return result
```

## 5. SQL / 数据处理伪代码高频

### 5.1 Top-K（小根堆）

```pseudo
function top_k(stream, k):
    heap = min_heap()
    for x in stream:
        if heap.size < k: heap.push(x)
        else if x > heap.top:
            heap.pop()
            heap.push(x)
    return heap_elements_sorted_desc()
```

### 5.2 去重保序

```pseudo
function dedup_keep_order(arr):
    seen = set()
    ans = []
    for x in arr:
        if x in seen: continue
        seen.add(x)
        ans.append(x)
    return ans
```

### 5.3 外部排序（超大文件）

```pseudo
function external_sort(file, chunk_size):
    runs = []
    while not EOF(file):
        chunk = read_chunk(file, chunk_size)
        sort(chunk)
        run_file = write_temp(chunk)
        runs.append(run_file)

    return k_way_merge(runs)
```

## 6. 面试官常见追问模板（写完伪代码后要主动补）

```text
1) 时间复杂度 / 空间复杂度
2) 边界情况: 空输入、单元素、重复值、异常输入
3) 是否支持 early stop
4) 失败如何落盘 / 重试 / 回滚
5) 如何做单元测试与压力测试
```

## 7. 30 秒速背（真到白板前最后看一眼）

```text
- 搜索题: 状态定义 + 扩展 + 打分 + 剪枝 + early stop
- 图题: BFS 最短路, DFS 枚举
- 区间题: 双指针 / 滑窗 / 前缀和
- 最优化: 二分答案 / DP
- 工程题: 缓存(LRU), 限流(令牌桶), 重试(指数退避), 幂等
- 项目题(MICS): Mentor 生成 -> Intern 评估 -> 选下一步 -> 日志落盘
```

